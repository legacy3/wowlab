# Prediction Engine Architecture

## Why CLEU Mirroring?

WowLab mirrors WoW's Combat Log Event Unfiltered (CLEU) system. This is not arbitrary - it enables the same codebase to work in two modes:

1. **Simulator mode**: WowLab emits CLEU events, handlers consume them to update state
2. **In-game mode**: WoW emits CLEU events, same handlers consume them to update state

The event types (`SPELL_CAST_SUCCESS`, `SPELL_AURA_APPLIED`, `SPELL_DAMAGE`, etc.) match WoW's actual combat log API.

## The Two Event Streams

A real prediction engine requires **two separate CLEU streams**:

### Real CLEU Stream (Authoritative)

Events that actually happened:

- In-game: received from WoW's combat log API
- Simulator: emitted by the simulation engine

These events are **authoritative**. They include:

- Procs that actually fired (RNG outcomes)
- Actual buff/debuff applications
- Real damage values
- Cooldown resets from procs
- Resource gains/costs

You cannot predict these with certainty. A spell might proc something, or it might not.

### Predicted CLEU Stream (Speculative)

Events that **would** happen if you cast the predicted spells:

- Generated by running the APL against a state snapshot
- Speculative - best guess based on current known state
- Does NOT know about future procs or RNG

Used for "next N spells" prediction (like Hekili addon).

## State Management

### Real State

- Updated **only** from real CLEU events
- Single source of truth for what actually happened
- Tracks: cooldowns, buffs, resources, unit health, etc.

### Prediction State

- Starts as a **snapshot** of real state
- Updated from predicted CLEU events during lookahead
- **Invalidated** whenever new real events arrive
- Rebuilt from fresh real state snapshot before each prediction cycle

```
Real CLEU ─────────────────────────────────────────────────────►
    │
    ▼
Real State (authoritative)
    │
    │ snapshot when prediction needed
    ▼
Prediction State ──► Run APL ──► Predicted CLEU ──┐
    │                     │                       │
    │                     ▼                       │
    │               Spell #1                      │
    │                     │                       │
    │     update state ◄──┘                       │
    │         │                                   │
    │         ▼                                   │
    │    Run APL ──► Predicted CLEU ──┐          │
    │         │                       │          │
    │         ▼                       │          │
    │   Spell #2                      │          │
    │         │                       │          │
    │    ... repeat for N spells ...  │          │
    │                                 │          │
    │                                 ▼          ▼
    │                          Predicted events buffer
    │                                 │
    │                                 ▼
    │                          "Next 3 spells" UI
    │
    └─── invalidate on new real CLEU ◄───────────────────────────
```

## Prediction Cycle

1. **Trigger**: New real CLEU event arrives (or timer/debounce)
2. **Snapshot**: Clone current real state
3. **Predict spell 1**: Run APL against snapshot → get spell to cast
4. **Simulate cast**: Generate predicted CLEU events for that cast
5. **Update prediction state**: Apply predicted events to snapshot
6. **Repeat** steps 3-5 for spells 2, 3, etc.
7. **Output**: List of predicted spells + predicted events
8. **Discard**: Throw away prediction state (it's stale immediately)

## Why Predicted Events Matter

You might think "just return the spell IDs". But predicted CLEU events are needed because:

1. **State updates**: Casting spell #1 puts it on cooldown, changes resources, might apply buffs. Spell #2 prediction needs this updated state.

2. **Handler reuse**: The same handlers that process real events can process predicted events. No duplicate logic.

3. **UI consistency**: Timeline/overlay can render predicted events the same way as real events.

4. **Debugging**: You can see exactly what the prediction engine thinks will happen.

## What Prediction Cannot Know

Prediction is limited because it cannot know:

- **Procs**: Will Kill Command reset its cooldown? (RNG)
- **External events**: Will the boss cast something? Will you take damage?
- **Other players**: In group content, others' actions affect state
- **Latency**: Actual cast timing differs from predicted timing

This is why prediction must be **continuously invalidated and rebuilt** as real events arrive.

## Consumer Use Cases

### In-Game Overlay (Hekili-style)

- Subscribes to: **Predicted stream**
- Shows: Next 3 recommended spells
- Updates: On every real CLEU event (triggers re-prediction)

### Timeline Renderer (Portal)

- Subscribes to: **Real stream**
- Shows: What actually happened in the simulation
- Updates: As simulation runs

### State Tracker

- Subscribes to: **Real stream**
- Purpose: Maintain authoritative game state
- Used by: Prediction engine as source of truth

### CLI Output

- Subscribes to: **Real stream** (and optionally predicted)
- Shows: ASCII timeline of events

## Implementation Requirements

### Event Bus

Need a pub/sub system that:

- Supports multiple subscribers
- Can filter by event type
- Has separate channels for real vs predicted events (or tag events)

### State Isolation

Prediction must not pollute real state:

- Snapshot real state before prediction
- Run prediction in isolated context
- Discard prediction state after

### Invalidation

When real events arrive:

- Cancel any in-progress prediction
- Mark prediction results as stale
- Re-run prediction from new real state

## Open Questions

1. **Granularity**: Predict on every GCD? Every real event? Debounced?
2. **Depth**: How many spells to predict? 3? 5? Configurable?
3. **RNG handling**: Assume procs don't happen? Average case? Configurable?
4. **Performance**: How fast must prediction complete? Target latency?
