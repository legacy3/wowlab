# Phase 0.5: Architecture Restructure

Restructure the rotation system architecture before implementing the new Expr API. This phase addresses structural issues identified in the current codebase to ensure the new API is built on solid foundations.

## Architectural Issues to Address

### Issue 1: Parallel Type Hierarchies

**Current state:**
```
VarPath (47 variants, string names)
    ↓ resolve_var() - 100-line 1:1 mapping
ResolvedVar (33 variants, resolved IDs)
```

Both enums represent the same semantic concepts. Every new variable type requires changes in both places.

**Solution:** Hybrid Expr design with domain-grouped sub-enums. See "New Type Architecture" below.

### Issue 2: Triple Expression Traversal

**Current state:**
1. First pass: `collect_vars_from_expr()` for schema building
2. Second pass: Validation
3. Third pass: `compile_bool_expr()` / `compile_numeric_expr()` with re-resolution

**Solution:** Single-pass compilation with `ResolvedExpr` intermediate representation.

### Issue 3: Monolithic populate_context

**Current state:** 500-line match statement mixing all domain logic.

**Solution:** Domain-specific populators with trait-based dispatch.

### Issue 4: Spec ID Duplication

**Current state:** IDs defined in 3 places per spec:
- `constants.rs` - `KILL_COMMAND = SpellIdx(34026)`
- `rotation.rs` - `.spell("kill_command", 34026)`
- `rotation.rs` - `34026 => Some(KILL_COMMAND)` (reverse lookup)

**Solution:** Single SpecRegistry as source of truth.

### Issue 5: Handler-Rotation Coupling

**Current state:** Handler directly calls `rotation.evaluate()` and does manual ID translation.

**Solution:** `RotationDecider` trait abstraction.

---

## New Type Architecture

### Expr with Domain Sub-Enums

Replace flat 149-variant design with grouped structure:

```rust
// src/rotation/expr.rs

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum Expr {
    // === Literals (3) ===
    Bool { value: bool },
    Int { value: i64 },
    Float { value: f64 },

    // === Logic (3) ===
    And { operands: Vec<Expr> },
    Or { operands: Vec<Expr> },
    Not { operand: Box<Expr> },

    // === Comparison (6) ===
    Gt { left: Box<Expr>, right: Box<Expr> },
    Gte { left: Box<Expr>, right: Box<Expr> },
    Lt { left: Box<Expr>, right: Box<Expr> },
    Lte { left: Box<Expr>, right: Box<Expr> },
    Eq { left: Box<Expr>, right: Box<Expr> },
    Ne { left: Box<Expr>, right: Box<Expr> },

    // === Arithmetic (5) ===
    Add { left: Box<Expr>, right: Box<Expr> },
    Sub { left: Box<Expr>, right: Box<Expr> },
    Mul { left: Box<Expr>, right: Box<Expr> },
    Div { left: Box<Expr>, right: Box<Expr> },
    Mod { left: Box<Expr>, right: Box<Expr> },

    // === Functions (5) ===
    Floor { operand: Box<Expr> },
    Ceil { operand: Box<Expr> },
    Abs { operand: Box<Expr> },
    Min { left: Box<Expr>, right: Box<Expr> },
    Max { left: Box<Expr>, right: Box<Expr> },

    // === Variables ===
    Var { name: String },  // User-defined variable reference

    // === Domain Conditions (grouped) ===
    Resource(ResourceExpr),
    Cooldown(CooldownExpr),
    Aura(AuraExpr),
    Combat(CombatExpr),
    Target(TargetExpr),
    Player(PlayerExpr),
    Spell(SpellExpr),
    Talent(TalentExpr),
    Gcd(GcdExpr),
    Pet(PetExpr),
}

// === Domain Sub-Enums ===

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ResourceExpr {
    Current { resource: String },
    Max { resource: String },
    Deficit { resource: String },
    DeficitPercent { resource: String },
    Percent { resource: String },
    Regen { resource: String },
    TimeToMax { resource: String },
    TimeTo { resource: String, amount: f64 },
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum CooldownExpr {
    Ready { spell: String },
    Remaining { spell: String },
    Duration { spell: String },
    BaseDuration { spell: String },
    Charges { spell: String },
    ChargesMax { spell: String },
    ChargesFractional { spell: String },
    RechargeTime { spell: String },
    FullRechargeTime { spell: String },
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum AuraExpr {
    Active { aura: String, on: AuraTarget },
    Inactive { aura: String, on: AuraTarget },
    Remaining { aura: String, on: AuraTarget },
    Stacks { aura: String, on: AuraTarget },
    StacksMax { aura: String, on: AuraTarget },
    Duration { aura: String, on: AuraTarget },
    Refreshable { aura: String, on: AuraTarget },
    Ticking { aura: String, on: AuraTarget },
    TicksRemaining { aura: String, on: AuraTarget },
    TickTime { aura: String, on: AuraTarget },
    NextTick { aura: String, on: AuraTarget },
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum AuraTarget {
    Player,
    Target,
    Pet,
}

// ... similar for CombatExpr, TargetExpr, PlayerExpr, SpellExpr, TalentExpr, GcdExpr, PetExpr
```

**Benefits:**
- Expr enum stays at ~25 variants (manageable)
- Domain logic grouped together
- Each sub-enum handles its own `return_type()` and validation
- Adding new domain variant only touches one sub-enum
- Pattern matching is organized by domain

### ResolvedExpr Intermediate Representation

Add resolved form for compilation:

```rust
// src/rotation/resolved.rs

/// Expression with all names resolved to IDs.
/// Produced by resolution pass, consumed by compiler.
pub enum ResolvedExpr {
    // Literals pass through unchanged
    Bool(bool),
    Int(i64),
    Float(f64),

    // Operators contain resolved children
    And(Vec<ResolvedExpr>),
    Or(Vec<ResolvedExpr>),
    Not(Box<ResolvedExpr>),
    // ... other operators ...

    // User variables resolved to index
    Var(VarIdx),

    // Domain conditions with resolved IDs
    Resource(ResolvedResourceExpr),
    Cooldown(ResolvedCooldownExpr),
    Aura(ResolvedAuraExpr),
    // ... etc ...
}

pub enum ResolvedResourceExpr {
    Current(ResourceType),
    Max(ResourceType),
    Deficit(ResourceType),
    // ... etc - no strings, only resolved types ...
}

pub enum ResolvedCooldownExpr {
    Ready(SpellIdx),
    Remaining(SpellIdx),
    Duration(SpellIdx),
    // ... etc - SpellIdx instead of String ...
}
```

**Benefits:**
- Clear separation: `Expr` (user input) vs `ResolvedExpr` (compiler input)
- No re-resolution during compilation
- Compile-time constants (talents) embedded during resolution
- Error messages can reference original strings from `Expr`

---

## New Module Structure

### src/rotation/

```
rotation/
├── mod.rs              # Public API exports
├── ast.rs              # Rotation, Action, VarOp (unchanged)
├── expr.rs             # NEW: Expr enum with domain sub-enums
├── resolved.rs         # NEW: ResolvedExpr for compilation
├── resolver.rs         # REWRITE: Expr → ResolvedExpr transformation
├── context/            # SPLIT from single file
│   ├── mod.rs          # ContextSchema, SchemaBuilder
│   ├── resource.rs     # Resource field population
│   ├── cooldown.rs     # Cooldown field population
│   ├── aura.rs         # Aura field population
│   ├── combat.rs       # Combat field population
│   ├── player.rs       # Player field population
│   └── populate.rs     # Orchestrates domain populators
├── compiler.rs         # UPDATE: Works with ResolvedExpr
├── validate.rs         # REWRITE: Validates Expr before resolution
├── parser.rs           # UPDATE: Deserializes new Expr structure
├── error.rs            # EXPAND: Rich error types
└── action.rs           # KEEP: Output types
```

### src/rotation/context/ Domain Split

```rust
// src/rotation/context/mod.rs

pub struct ContextSchema {
    pub size: usize,
    pub fields: Vec<ContextField>,
    offsets: HashMap<FieldId, usize>,
}

pub struct ContextField {
    pub id: FieldId,
    pub offset: usize,
    pub field_type: FieldType,
}

/// Unique identifier for a context field.
/// Replaces ResolvedVar as HashMap key.
#[derive(Debug, Clone, Hash, Eq, PartialEq)]
pub enum FieldId {
    Resource { resource: ResourceType, kind: ResourceFieldKind },
    Cooldown { spell: SpellIdx, kind: CooldownFieldKind },
    Aura { aura: AuraIdx, target: AuraTarget, kind: AuraFieldKind },
    Combat(CombatFieldKind),
    Target(TargetFieldKind),
    Player(PlayerFieldKind),
    Spell { spell: SpellIdx, kind: SpellFieldKind },
    Talent(TalentIdx),
    Gcd(GcdFieldKind),
    Pet(PetFieldKind),
    UserVar(VarIdx),
}

#[derive(Debug, Clone, Copy, Hash, Eq, PartialEq)]
pub enum ResourceFieldKind { Current, Max, Deficit, DeficitPercent, Percent, Regen, TimeToMax }

#[derive(Debug, Clone, Copy, Hash, Eq, PartialEq)]
pub enum CooldownFieldKind { Ready, Remaining, Duration, BaseDuration, Charges, ChargesMax, ChargesFractional, RechargeTime, FullRechargeTime }

// ... similar for other domains ...
```

```rust
// src/rotation/context/populate.rs

pub fn populate_context(buffer: &mut [u8], schema: &ContextSchema, state: &SimState) {
    for field in &schema.fields {
        match &field.id {
            FieldId::Resource { resource, kind } => {
                resource::populate(buffer, field.offset, state, *resource, *kind);
            }
            FieldId::Cooldown { spell, kind } => {
                cooldown::populate(buffer, field.offset, state, *spell, *kind);
            }
            FieldId::Aura { aura, target, kind } => {
                aura::populate(buffer, field.offset, state, *aura, *target, *kind);
            }
            // ... dispatch to domain modules ...
        }
    }
}
```

```rust
// src/rotation/context/resource.rs

pub fn populate(
    buffer: &mut [u8],
    offset: usize,
    state: &SimState,
    resource: ResourceType,
    kind: ResourceFieldKind,
) {
    let pool = state.player.resources.get_pool(resource);
    let value = match kind {
        ResourceFieldKind::Current => pool.current as f64,
        ResourceFieldKind::Max => pool.max as f64,
        ResourceFieldKind::Deficit => (pool.max - pool.current).max(0.0) as f64,
        ResourceFieldKind::DeficitPercent => {
            if pool.max > 0.0 {
                ((pool.max - pool.current) / pool.max * 100.0).max(0.0)
            } else {
                0.0
            }
        }
        ResourceFieldKind::Percent => {
            if pool.max > 0.0 {
                (pool.current / pool.max * 100.0).clamp(0.0, 100.0)
            } else {
                0.0
            }
        }
        ResourceFieldKind::Regen => state.player.resource_regen(resource) as f64,
        ResourceFieldKind::TimeToMax => {
            let deficit = (pool.max - pool.current).max(0.0);
            let regen = state.player.resource_regen(resource);
            if regen > 0.0 { deficit / regen } else { f64::MAX }
        }
    };
    write_f64(buffer, offset, value);
}
```

**Benefits:**
- Each domain's population logic in its own file (~50-80 lines each)
- Easy to test domain logic in isolation
- Clear ownership of field types per domain
- No 500-line match statement

---

## Spec Registry

### Single Source of Truth

```rust
// src/specs/registry.rs

/// Central registry for spec-specific data.
/// Single source of truth - no ID duplication.
pub struct SpecRegistry {
    spec_id: SpecId,
    spells: HashMap<&'static str, SpellEntry>,
    auras: HashMap<&'static str, AuraEntry>,
    talents: HashMap<&'static str, TalentEntry>,
}

pub struct SpellEntry {
    pub idx: SpellIdx,
    pub def: &'static SpellDef,
}

pub struct AuraEntry {
    pub idx: AuraIdx,
    pub def: &'static AuraDef,
}

pub struct TalentEntry {
    pub idx: TalentIdx,
    pub enabled: bool,
}

impl SpecRegistry {
    /// Resolve spell name to index. Used by rotation resolver.
    pub fn resolve_spell(&self, name: &str) -> Option<SpellIdx> {
        self.spells.get(name).map(|e| e.idx)
    }

    /// Resolve aura name to index. Used by rotation resolver.
    pub fn resolve_aura(&self, name: &str) -> Option<AuraIdx> {
        self.auras.get(name).map(|e| e.idx)
    }

    /// Check if talent is enabled. Used by rotation resolver.
    pub fn talent_enabled(&self, name: &str) -> Option<bool> {
        self.talents.get(name).map(|e| e.enabled)
    }

    /// Get spell definition by index. Used by handler.
    pub fn spell_def(&self, idx: SpellIdx) -> Option<&'static SpellDef> {
        self.spells.values().find(|e| e.idx == idx).map(|e| e.def)
    }

    /// Build rotation resolver from this registry.
    pub fn to_rotation_resolver(&self) -> RotationResolver {
        RotationResolver::new(self)
    }
}
```

### Spec Implementation

```rust
// src/specs/hunter/bm/registry.rs

pub fn build_registry(talents: TalentFlags) -> SpecRegistry {
    let mut registry = SpecRegistry::new(SpecId::BeastMasteryHunter);

    // Spells - defined ONCE
    registry.register_spell("kill_command", SpellIdx(34026), &KILL_COMMAND_DEF);
    registry.register_spell("cobra_shot", SpellIdx(193455), &COBRA_SHOT_DEF);
    registry.register_spell("barbed_shot", SpellIdx(217200), &BARBED_SHOT_DEF);
    // ... all spells ...

    // Auras - defined ONCE
    registry.register_aura("bestial_wrath", AuraIdx(19574), &BESTIAL_WRATH_DEF);
    registry.register_aura("frenzy", AuraIdx(272790), &FRENZY_DEF);
    // ... all auras ...

    // Talents - with current state
    registry.register_talent("animal_companion", TalentIdx(1),
        talents.contains(TalentFlags::ANIMAL_COMPANION));
    registry.register_talent("killer_instinct", TalentIdx(2),
        talents.contains(TalentFlags::KILLER_INSTINCT));
    // ... all talents ...

    registry
}
```

**Benefits:**
- No more triple ID definition
- Reverse lookup generated automatically from forward registration
- Talent state captured at registry build time
- Handler and rotation share same registry instance

---

## Handler Abstraction

### RotationDecider Trait

```rust
// src/rotation/decider.rs

/// Abstraction for rotation decision logic.
/// Decouples handler from rotation implementation details.
pub trait RotationDecider: Send + Sync {
    /// Evaluate rotation and return next action.
    fn decide(&self, state: &SimState) -> RotationAction;
}

/// Output from rotation evaluation.
/// Handler works with this, not raw EvalResult.
pub enum RotationAction {
    Cast(SpellIdx),
    Wait(f64),
    Pool { extra_deficit: f64 },
    Idle,
}

/// Adapter wrapping CompiledRotation.
pub struct CompiledRotationDecider {
    compiled: CompiledRotation,
    registry: Arc<SpecRegistry>,
}

impl RotationDecider for CompiledRotationDecider {
    fn decide(&self, state: &SimState) -> RotationAction {
        let result = self.compiled.evaluate(state);

        match result.kind {
            EvalResultKind::Cast => {
                self.registry.resolve_spell_by_id(result.spell_id)
                    .map(RotationAction::Cast)
                    .unwrap_or(RotationAction::Idle)
            }
            EvalResultKind::Wait => RotationAction::Wait(result.wait_time),
            EvalResultKind::Pool => RotationAction::Pool {
                extra_deficit: result.pool_extra
            },
            EvalResultKind::Idle => RotationAction::Idle,
        }
    }
}
```

### Handler Usage

```rust
// src/specs/hunter/bm/handler.rs

impl SpecHandler for BmHunter {
    fn on_gcd(&self, state: &mut SimState) {
        if state.finished { return; }

        // Clean interface - no ID translation in handler
        match self.rotation.decide(state) {
            RotationAction::Cast(spell) => {
                self.do_cast(state, spell, TargetIdx(0));
            }
            RotationAction::Wait(seconds) => {
                let ms = (seconds * 1000.0) as u32;
                state.schedule_in(SimTime::from_millis(ms.max(100)), SimEvent::GcdEnd);
            }
            RotationAction::Pool { extra_deficit } => {
                // Pool until resource deficit is met
                self.pool_resources(state, extra_deficit);
            }
            RotationAction::Idle => {
                state.schedule_in(SimTime::from_millis(100), SimEvent::GcdEnd);
            }
        }
    }
}
```

**Benefits:**
- Handler doesn't know about EvalResult internals
- ID translation happens in one place (CompiledRotationDecider)
- Can swap rotation implementations (JIT, interpreter, scripted) without changing handler
- Testing: can mock RotationDecider

---

## Compilation Pipeline

### Single-Pass Resolution and Schema Building

```rust
// src/rotation/resolver.rs

pub struct RotationResolver<'a> {
    registry: &'a SpecRegistry,
    variables: HashMap<String, ResolvedExpr>,
    schema_builder: SchemaBuilder,
    errors: Vec<ResolutionError>,
}

impl<'a> RotationResolver<'a> {
    /// Resolve entire rotation in single pass.
    /// Returns resolved AST and schema together.
    pub fn resolve(
        rotation: &Rotation,
        registry: &'a SpecRegistry,
    ) -> Result<(ResolvedRotation, ContextSchema), ResolutionErrors> {
        let mut resolver = Self::new(registry);

        // Resolve variables first (they may be referenced by actions)
        let resolved_vars = resolver.resolve_variables(&rotation.variables)?;

        // Resolve action lists
        let resolved_lists = resolver.resolve_lists(&rotation.lists)?;

        // Resolve main actions
        let resolved_actions = resolver.resolve_actions(&rotation.actions)?;

        // Build schema from collected fields
        let schema = resolver.schema_builder.build();

        Ok((
            ResolvedRotation {
                name: rotation.name.clone(),
                variables: resolved_vars,
                lists: resolved_lists,
                actions: resolved_actions,
            },
            schema,
        ))
    }

    fn resolve_expr(&mut self, expr: &Expr) -> Result<ResolvedExpr, ResolutionError> {
        match expr {
            Expr::Bool { value } => Ok(ResolvedExpr::Bool(*value)),
            Expr::Int { value } => Ok(ResolvedExpr::Int(*value)),
            Expr::Float { value } => Ok(ResolvedExpr::Float(*value)),

            Expr::And { operands } => {
                let resolved: Result<Vec<_>, _> = operands.iter()
                    .map(|e| self.resolve_expr(e))
                    .collect();
                Ok(ResolvedExpr::And(resolved?))
            }

            Expr::Resource(res) => self.resolve_resource_expr(res),
            Expr::Cooldown(cd) => self.resolve_cooldown_expr(cd),
            Expr::Aura(aura) => self.resolve_aura_expr(aura),
            // ... etc ...
        }
    }

    fn resolve_cooldown_expr(&mut self, expr: &CooldownExpr) -> Result<ResolvedExpr, ResolutionError> {
        match expr {
            CooldownExpr::Ready { spell } => {
                let spell_idx = self.registry.resolve_spell(spell)
                    .ok_or_else(|| ResolutionError::UnknownSpell {
                        name: spell.clone(),
                        suggestion: self.registry.suggest_spell(spell),
                    })?;

                // Add to schema during resolution (single pass)
                let field_id = FieldId::Cooldown {
                    spell: spell_idx,
                    kind: CooldownFieldKind::Ready
                };
                self.schema_builder.add_field(field_id, FieldType::Bool);

                Ok(ResolvedExpr::Cooldown(ResolvedCooldownExpr::Ready(spell_idx)))
            }
            // ... other cooldown variants ...
        }
    }
}
```

**Benefits:**
- Single traversal resolves names AND builds schema
- No re-resolution during compilation
- Errors collected with original string names for good messages
- Schema complete before JIT compilation starts

---

## Implementation Order

### Phase 0.5a: Type Foundation
1. Create `src/rotation/expr.rs` with domain sub-enums
2. Create `src/rotation/resolved.rs` with ResolvedExpr
3. Create `src/rotation/context/` directory structure
4. Implement FieldId enum and domain field kinds

### Phase 0.5b: Resolution Pipeline
1. Rewrite `src/rotation/resolver.rs` for Expr → ResolvedExpr
2. Implement single-pass schema building
3. Update error types with suggestions

### Phase 0.5c: Context Split
1. Move population logic to domain files
2. Implement trait-based dispatch in populate.rs
3. Remove old monolithic populate_context

### Phase 0.5d: Spec Registry
1. Create `src/specs/registry.rs`
2. Update BM Hunter to use registry
3. Update MM Hunter to use registry
4. Remove duplicate ID definitions

### Phase 0.5e: Handler Abstraction
1. Create `src/rotation/decider.rs` with RotationDecider trait
2. Implement CompiledRotationDecider
3. Update handlers to use trait

### Phase 0.5f: Compiler Update
1. Update compiler to work with ResolvedExpr
2. Remove resolution from compilation pass
3. Verify JIT output unchanged

---

## Verification

After each sub-phase:
```bash
cargo build           # Must compile
cargo test            # Must pass
```

After full phase:
```bash
cargo bench           # Performance regression check
```

---

## Files Changed Summary

| File | Change |
|------|--------|
| `rotation/ast.rs` | Keep Rotation, Action, VarOp. Remove old Expr, VarPath |
| `rotation/expr.rs` | NEW: Expr with domain sub-enums |
| `rotation/resolved.rs` | NEW: ResolvedExpr intermediate representation |
| `rotation/resolver.rs` | REWRITE: Single-pass Expr → ResolvedExpr |
| `rotation/context/` | NEW: Split into domain modules |
| `rotation/compiler.rs` | UPDATE: Use ResolvedExpr, remove inline resolution |
| `rotation/validate.rs` | UPDATE: Validate Expr before resolution |
| `rotation/decider.rs` | NEW: RotationDecider trait |
| `specs/registry.rs` | NEW: SpecRegistry |
| `specs/hunter/bm/registry.rs` | NEW: BM registry builder |
| `specs/hunter/bm/handler.rs` | UPDATE: Use RotationDecider |
| `specs/hunter/bm/rotation.rs` | UPDATE: Use SpecRegistry |
| `specs/hunter/bm/constants.rs` | SIMPLIFY: Remove duplicate IDs |

---

## Risk Assessment

| Risk | Mitigation |
|------|------------|
| Breaking existing rotations | Keep Serde compatibility with old JSON format |
| Performance regression | Benchmark after each sub-phase |
| Complex migration | Sub-phases allow incremental verification |
| WASM compatibility | Test WASM build after type changes |

---

## Dependencies

This phase must complete before:
- Phase 1-9 (which implement domain Expr variants)

This phase has no external dependencies.
