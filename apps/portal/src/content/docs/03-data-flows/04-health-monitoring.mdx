---
title: Health Monitoring
description: Node health tracking, heartbeats, and chunk reclamation
---

# Health Monitoring

Node health is tracked through heartbeats, with presence events as optimization hints.

## Health Sources

```mermaid
flowchart TB
    subgraph Authoritative["Authoritative (Redis)"]
        Heartbeat["last_heartbeat timestamp<br/>Updated via refresh proxy"]
    end

    subgraph Hints["Hints (Centrifugo)"]
        Presence["Presence join/leave events<br/>At-most-once delivery"]
    end

    subgraph Decisions["Health Decisions"]
        Assign[Chunk assignment]
        Reclaim[Chunk reclamation]
    end

    Heartbeat -->|Primary| Decisions
    Presence -->|Optimization| Decisions
```

## Heartbeat Flow

Heartbeats happen automatically via Centrifugo's refresh mechanism:

```mermaid
sequenceDiagram
    participant Node
    participant Centrifugo
    participant Sentinel
    participant Redis

    Note over Centrifugo: Token approaching expiration

    Centrifugo->>Sentinel: POST /proxy/refresh
    Sentinel->>Sentinel: Verify proxy secret

    Sentinel->>Redis: EVALSHA heartbeat
    Note over Redis: Update last_heartbeat<br/>Refresh TTL<br/>Update backlog ZSet
    Redis-->>Sentinel: {backlog, OK}

    Sentinel->>Sentinel: Issue new JWT
    Sentinel-->>Centrifugo: {result: {expire_at}}

    Centrifugo-->>Node: Token refreshed (transparent)
```

### Heartbeat Lua Script

```lua
-- KEYS[1] = {node}:{node_id}:state
-- KEYS[2] = {node}:backlog:sorted

redis.call('HSET', KEYS[1], 'last_heartbeat', now)
redis.call('EXPIRE', KEYS[1], 7200) -- 2h TTL

-- Ensure node is in backlog ZSet
redis.call('HSETNX', KEYS[1], 'backlog', 0)
local backlog = redis.call('HGET', KEYS[1], 'backlog')
redis.call('ZADD', KEYS[2], backlog, node_id)
```

## Background Health Monitor

A single leader sentinel runs health monitoring:

```mermaid
flowchart TD
    subgraph Leader["Leader Election"]
        TryLock{SET NX background:leader}
        TryLock -->|Acquired| RunTasks[Run health monitor]
        TryLock -->|Failed| Skip[Skip this cycle]
    end

    subgraph Monitor["Health Monitor (every 30s)"]
        GetNodes[Get all nodes from ZSet]
        CheckHeartbeats[Check each heartbeat]
        IdentifyDead[Identify dead nodes]
        ReclaimChunks[Reclaim chunks]
    end

    RunTasks --> Monitor
```

```rust
// Leader election
let acquired = redis.set_nx_ex("background:leader", instance_id, 30).await?;
if !acquired {
    return Ok(()); // Another instance is leader
}

// Run health checks
loop {
    check_node_health().await?;
    recover_stuck_locks().await?;

    // Refresh leader lease
    redis.expire("background:leader", 30).await?;
    sleep(Duration::from_secs(10)).await;
}
```

## Node Health States

```mermaid
stateDiagram-v2
    [*] --> Healthy: Connect + heartbeat
    Healthy --> Healthy: Heartbeat < 60s
    Healthy --> Warning: Heartbeat 60-90s
    Warning --> Healthy: New heartbeat
    Warning --> Dead: Heartbeat > 90s
    Dead --> [*]: Chunks reclaimed
```

| State   | Heartbeat Age | Action                  |
| ------- | ------------- | ----------------------- |
| Healthy | < 60s         | Eligible for new chunks |
| Warning | 60-90s        | No new chunks, monitor  |
| Dead    | > 90s         | Reclaim all chunks      |

## Presence as Optimization

Presence events can accelerate disconnect detection:

```mermaid
sequenceDiagram
    participant Node
    participant Centrifugo
    participant Sentinel
    participant Redis

    Node->>Centrifugo: Disconnect (network failure)
    Centrifugo-->>Sentinel: Presence leave event

    Sentinel->>Sentinel: Note: Node may be offline
    Sentinel->>Redis: HGET {node}:{id}:state last_heartbeat
    Redis-->>Sentinel: timestamp

    alt Heartbeat recent (< 60s)
        Note over Sentinel: Wait - node may reconnect
    else Heartbeat stale (> 90s)
        Note over Sentinel: Proceed with reclaim
        Sentinel->>Redis: EVALSHA reclaim_chunks
    end
```

**Important:** Never trust presence alone. Always verify with heartbeat timestamp.

## Chunk Reclamation

```mermaid
sequenceDiagram
    participant Sentinel
    participant Redis
    participant Centrifugo
    participant NewNode

    Sentinel->>Redis: EVALSHA reclaim_chunks
    Note over Redis: Get chunks from {node}:{id}:chunks<br/>Clear node state<br/>Remove from backlog ZSet
    Redis-->>Sentinel: [chunk-1, chunk-2, ...]

    loop For each chunk
        Sentinel->>Redis: EXISTS {chunk}:{id}
        alt Chunk exists (not yet completed)
            Sentinel->>Redis: EVALSHA select_nodes (count=1)
            Redis-->>Sentinel: [new-node-id]
            Sentinel->>Redis: EVALSHA assign_chunk
            Sentinel->>Centrifugo: Publish to nodes:{new-node}
            Centrifugo-->>NewNode: Chunk reassignment
        else Chunk already completed
            Note over Sentinel: Skip - was completed before reclaim
        end
    end
```

### Reclaim Lua Script

```lua
-- KEYS[1] = {node}:{node_id}:state
-- KEYS[2] = {node}:{node_id}:chunks
-- KEYS[3] = {node}:backlog:sorted

local chunks = redis.call('SMEMBERS', KEYS[2])

redis.call('DEL', KEYS[1])
redis.call('DEL', KEYS[2])
redis.call('ZREM', KEYS[3], node_id)

return chunks
```

## Race Condition: Completion vs Reclaim

```mermaid
sequenceDiagram
    participant OldNode
    participant Sentinel1
    participant Sentinel2
    participant Redis

    Note over OldNode,Sentinel2: Node disconnected, completing chunk

    par Reclaim Process
        Sentinel1->>Redis: reclaim_chunks
        Redis-->>Sentinel1: [chunk-1]
    and Completion
        OldNode->>Sentinel2: Complete chunk-1
        Sentinel2->>Redis: complete_chunk
    end

    alt Completion wins
        Note over Redis: chunk-1 deleted by completion
        Sentinel1->>Redis: EXISTS {chunk}:chunk-1
        Redis-->>Sentinel1: 0 (doesn't exist)
        Note over Sentinel1: Skip - already completed
    else Reclaim wins
        Sentinel2->>Redis: complete_chunk
        Redis-->>Sentinel2: WRONG_NODE or NOT_FOUND
        Note over Sentinel2: Completion rejected
    end
```

Both outcomes are correct:

- If completion wins: chunk is done, no reassignment needed
- If reclaim wins: old node's late completion is rejected, new node completes it

## Scalability Considerations

At scale (1000+ nodes), optimize health checks:

```mermaid
flowchart TD
    Current["Current: Poll each node<br/>O(n) Redis calls"] --> Optimized["Optimized Options"]

    subgraph Optimized
        Batch["Batch MGET<br/>O(1) call for many nodes"]
        Push["Push-based<br/>Subscribe to presence events"]
        Hybrid["Hybrid<br/>Presence for fast detection<br/>Heartbeat for confirmation"]
    end
```

### Batch Heartbeat Check

```rust
// Instead of N HGET calls:
let keys: Vec<String> = node_ids.iter()
    .map(|id| format!("{{node}}:{}:state", id))
    .collect();

let heartbeats: Vec<Option<i64>> = redis.mget(&keys).await?;

for (node_id, last_hb) in node_ids.iter().zip(heartbeats) {
    if let Some(hb) = last_hb {
        if now - hb > 90 {
            dead_nodes.push(node_id);
        }
    }
}
```
