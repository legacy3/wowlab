---
title: Auras & Procs
description: How buffs, debuffs, and proc effects work
updatedAt: 2026-01-17
---

# Auras & Procs

How the engine tracks buffs and debuffs, and how proc effects trigger.

## Aura lifecycle

<Mermaid chart={`
stateDiagram-v2
    [*] --> Applied: apply aura
    Applied --> Active: start ticking
    Active --> Refreshed: refresh()
    Refreshed --> Active: pandemic extend
    Active --> Expired: time up
    Expired --> [*]: remove

    state Active {
        [*] --> Ticking
        Ticking --> NextTick: tick()
        NextTick --> Ticking: schedule
    }

`} />

## AuraInstance structure

Each active aura is tracked as an instance:

```rust
AuraInstance {
    aura_id: AuraIdx,
    target: TargetIdx,
    expires_at: SimTime,
    base_duration: SimTime,
    stacks: u8,
    max_stacks: u8,
    snapshot: Option<ActionState>,  // For DoT snapshotting
    flags: AuraFlags,               // Behavior flags
    next_tick: Option<SimTime>,
    tick_interval: Option<SimTime>, // None for non-periodic
    remaining_ticks: u8,
}
```

## Aura flags

Flags control aura behavior:

```rust
AuraFlags {
    is_debuff: bool,
    is_periodic: bool,
    can_pandemic: bool,     // 30% extension cap
    snapshots: bool,        // Captures stats
    is_hidden: bool,
    refreshable: bool,
}
```

| Flag           | Effect                              |
| -------------- | ----------------------------------- |
| `is_debuff`    | Applied to enemies, not player      |
| `is_periodic`  | Has tick damage/healing             |
| `can_pandemic` | Refresh extends up to 130% duration |
| `snapshots`    | Captures stats at application       |
| `refreshable`  | Can be refreshed before expiring    |

## Pandemic refresh

When refreshing a DoT, remaining duration adds to the new duration up to 30% of base:

```
max_extension = base_duration * 0.3
new_duration = base_duration + min(remaining, max_extension)
```

Example: A 15s DoT with 5s remaining refreshes to 15 + 4.5 = 19.5s (capped at 130%).

## AuraTracker organization

<Mermaid chart={`
flowchart TB
    Tracker[AuraTracker]

    Tracker --> Player[player: TargetAuras]
    Tracker --> Targets[targets: Vec TargetAuras]

    Player --> Buffs[Player Buffs]
    Targets --> T0[Target 0 Debuffs]
    Targets --> T1[Target 1 Debuffs]
    Targets --> TN[Target N Debuffs]

    subgraph TargetAuras
        SmallVec["SmallVec<[AuraInstance; 16]>"]
    end

`} />

Buffs live on the player. Debuffs live on each target. The tracker provides fast lookups by aura ID and target.

## Proc system

Procs trigger effects when conditions are met. Two main types:

### RPPM (Real PPM)

Procs per minute scaled by haste, with bad luck protection:

```rust
RppmState {
    proc_id: ProcIdx,
    base_ppm: f32,
    last_proc: SimTime,
    last_attempt: SimTime,
    blp_multiplier: f32,   // Bad luck protection multiplier
    haste_scaling: bool,   // Whether PPM scales with haste
    crit_scaling: bool,    // Whether PPM scales with crit
    icd: Option<SimTime>,  // Internal cooldown
}
```

**Proc chance calculation:**

```
effective_ppm = base_ppm * haste  (if haste_scaling)
time_since_attempt = now - last_attempt
base_chance = effective_ppm * time_since_attempt / 60
final_chance = base_chance * blp_multiplier
```

Bad luck protection increases the `blp_multiplier` on failed attempts:

```
blp_multiplier *= (1 + time_factor * 3)
```

The multiplier resets to 1.0 on successful proc.

### Fixed chance

Simple percentage chance with optional internal cooldown:

```rust
FixedProc {
    proc_id: ProcIdx,
    chance: f32,              // 0.0 - 1.0
    icd: Option<SimTime>,     // Internal cooldown (if any)
    last_proc: Option<SimTime>,
}
```

## Proc registry

<Mermaid chart={`
flowchart TB
    subgraph ProcRegistry
        RPPM[RPPM Procs]
        Fixed[Fixed Procs]
        Handlers[ProcHandlers]
    end

    subgraph RppmState
        BaseRate[base_ppm]
        LastAttempt[last_attempt]
        LastProc[last_proc]
        BLPMult[blp_multiplier]
    end

    subgraph FixedProc
        Chance[chance]
        ICD[icd]
        LastProcFixed[last_proc]
    end

    RPPM --> RppmState
    Fixed --> FixedProc

`} />

## Proc effects

When a proc triggers, it executes one or more effects:

```rust
ProcEffect::ApplyAura { aura }
ProcEffect::CastSpell { spell }
ProcEffect::Damage { base, coefficient }
ProcEffect::Resource { resource, amount }
ProcEffect::ReduceCooldown { spell, amount }
ProcEffect::ExtendAura { aura, amount }
ProcEffect::AddStacks { aura, stacks }
ProcEffect::Multiple(Vec<ProcEffect>)
```

| Effect           | Description                        |
| ---------------- | ---------------------------------- |
| `ApplyAura`      | Apply a new aura                   |
| `CastSpell`      | Cast a spell (like trinket procs)  |
| `Damage`         | Deal direct damage                 |
| `Resource`       | Grant or consume resources         |
| `ReduceCooldown` | Lower a spell's remaining cooldown |
| `ExtendAura`     | Extend an aura's duration          |
| `AddStacks`      | Add stacks to an existing aura     |
| `Multiple`       | Execute multiple effects at once   |

## Next steps

- [Damage System](/dev/docs/reference/03-damage-system) - How auras affect damage
- [Spec Handlers](/dev/docs/engine/03-spec-handlers) - Implementing spec-specific procs
