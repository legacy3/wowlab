---
title: Event System
description: Timing wheel and event processing
nextSteps:
  - 04-engine/02-jit-compiler
  - 04-engine/03-implementing-specs
---

# Event System

The engine processes combat as a sequence of timestamped events. A timing wheel provides efficient scheduling and retrieval.

## Event types

| Event           | Trigger          | Handler              |
| --------------- | ---------------- | -------------------- |
| `GcdEnd`        | GCD expires      | Evaluate rotation    |
| `CastComplete`  | Cast finishes    | Apply spell effects  |
| `SpellDamage`   | Travel time ends | Deal damage          |
| `AuraTick`      | Tick interval    | DoT/HoT damage       |
| `AuraExpire`    | Duration ends    | Remove aura          |
| `AutoAttack`    | Swing timer      | Melee damage + procs |
| `PetAttack`     | Pet swing        | Pet melee            |
| `ResourceTick`  | Every 100ms      | Regeneration         |
| `CooldownReady` | CD expires       | Informational        |
| `ChargeReady`   | Recharge done    | Restore charge       |
| `ProcIcdEnd`    | ICD expires      | Proc can trigger     |

## Event queue

The `EventQueue` is a priority queue sorted by time:

```rust
pub struct EventQueue {
    events: BinaryHeap<Reverse<Event>>,
}

impl EventQueue {
    pub fn schedule(&mut self, event: Event);
    pub fn pop(&mut self) -> Option<Event>;
    pub fn peek(&self) -> Option<&Event>;
}
```

Events schedule in O(log n) and pop in O(log n).

## Event structure

```rust
pub struct Event {
    pub time: SimTime,
    pub kind: EventKind,
    pub data: EventData,
}
```

`SimTime` is milliseconds as `u32`. Max duration ~49 days, more than enough for any fight.

## Processing loop

```rust
while let Some(event) = events.pop() {
    state.advance_time(event.time);

    match event.kind {
        EventKind::GcdEnd => handler.on_gcd(state),
        EventKind::CastComplete => {
            handler.on_cast_complete(state, event.spell, event.target);
        }
        EventKind::SpellDamage => {
            handler.on_spell_damage(state, event.spell, event.target);
        }
        // ... other events
    }

    if state.finished {
        break;
    }
}
```

## Time resolution

`SimTime` provides millisecond precision:

```rust
pub struct SimTime(u32);

impl SimTime {
    pub fn from_secs_f32(secs: f32) -> Self;
    pub fn as_secs_f32(&self) -> f32;
    pub fn as_millis(&self) -> u32;
}
```

Arithmetic is saturating to prevent overflow.

## Event scheduling patterns

### GCD chain

```rust
// After casting, schedule next GCD
let gcd = spell.gcd.resolve(state.player.haste());
state.events.schedule(Event {
    time: state.time + gcd,
    kind: EventKind::GcdEnd,
    data: EventData::None,
});
```

### Damage with travel time

```rust
// Spell cast complete, schedule damage
let travel = spell.travel_time(state.target_distance());
state.events.schedule(Event {
    time: state.time + travel,
    kind: EventKind::SpellDamage,
    data: EventData::Spell { id: spell_id, target },
});
```

### Periodic aura

```rust
// Schedule first tick
state.events.schedule(Event {
    time: state.time + tick_interval,
    kind: EventKind::AuraTick,
    data: EventData::Aura { id: aura_id, target },
});
```

## Determinism

Events with identical timestamps process in insertion order. This ensures deterministic simulation when given the same RNG seed.
