---
title: Known Issues
description: Current limitations and areas for improvement
---

# Known Issues

Current limitations and anti-patterns in the engine.

## Critical issues

### Hardcoded armor constant

`combat/damage/pipeline.rs:128`

```rust
const ARMOR_CONSTANT: f32 = 7390.0;
```

Armor mitigation uses a constant for level 80 targets. Simulating different target levels gives incorrect mitigation.

**Impact**: Physical damage calculations wrong for non-80 targets.

**Fix needed**: Make armor constant configurable per target level.

### Pet stat inheritance inconsistency

`actor/pet.rs:77`

- AP/SP scaled by inheritance factor (passed as parameter)
- Haste/Crit ratings copied directly (not scaled)

Some stats scale, others don't. This matches WoW behavior but can be confusing when reading the code.

**Impact**: Pet damage may be slightly off if inheritance rules are misunderstood.

### Talents as compile-time constants

`rotation/expr/talent.rs`

Talents are baked into JIT code at compile time. Changing talents requires recompiling the rotation.

**Impact**: Cannot dynamically toggle talents without recompilation.

**Tradeoff**: Faster runtime evaluation vs flexibility.

## Performance concerns

### Proc registry lookup

`proc/registry.rs:39`

O(n) linear search through handlers for each proc check.

```rust
// Current: O(n) per check
self.handlers.iter().find(|h| h.id == rppm.proc_id)
```

**Impact**: Scales poorly with many proc handlers.

**Fix needed**: HashMap with ProcIdx key for O(1) lookup.

### Context buffer allocation

`rotation/compiler.rs:223`

```rust
let mut buffer = vec![0u8; self.schema.size.max(8)];
```

Buffer allocated on every rotation evaluation.

**Impact**: Allocation overhead on hot path.

**Fix needed**: Thread-local arena or pre-allocated buffer.

### String-based talent checks

`spec/executor.rs:161`

```rust
ctx.talents.contains(&name.as_str())
```

O(n) string comparison for each talent check.

**Impact**: Scales poorly with many talents and frequent checks.

**Fix needed**: Use talent indices or HashMap for O(1) lookup.

## Design issues

### Dual parse paths

`rotation/parser.rs:20`

- `from_json()` - Returns unresolved AST
- `from_json_resolved()` - Returns resolved AST

Two parse functions that look similar but have different outputs. The unresolved version leaves variable paths as strings; the resolved version translates names to IDs.

**Impact**: Easy to use wrong function and get confusing errors.

**Fix needed**: Single parse function with explicit resolution step.

### Incomplete spell information

`rotation/expr/spell.rs:47`

Some expressions have TODO implementations:

- `Cost`: Returns 0
- `CastTime`: Returns 0
- `Range`: Returns 40 (hardcoded default)

**Impact**: Rotations cannot make decisions based on these values.

**Fix needed**: Wire up SpellDef data to expression evaluation.

### Missing SchoolModifiers integration

`combat/damage/multipliers.rs:84`

`SchoolModifiers` struct exists but is not used in the damage pipeline.

```rust
pub struct SchoolModifiers {
    pub physical: f32,
    pub fire: f32,
    // ...
}
```

**Impact**: Per-school debuffs do not affect damage calculations.

**Fix needed**: Apply school modifiers in damage pipeline.

### Silent tuning failures

`data/local.rs:70`

If a spell name in the tuning file does not match any SpellDef, it is silently ignored. The loader iterates over spells and looks up tuning entries, but never validates that all tuning entries were used.

**Impact**: Typos in tuning files cause values to be ignored without warning.

**Fix needed**: Log warnings for unused tuning entries.

## Recommendations

### High priority

1. **Integrate SchoolModifiers** - Connect to damage pipeline
2. **Add tuning validation** - Log warnings for unused entries
3. **Wire up spell expressions** - Cost, CastTime, Range should use SpellDef

### Medium priority

1. **HashMap for proc lookups** - Replace O(n) scan with O(1)
2. **Cache context buffer** - Thread-local allocation
3. **Parameterize armor constant** - Support different target levels
4. **Index talent lookups** - Replace string comparison with indices

### Low priority

1. **Unify parse paths** - Single parse function with explicit resolution
2. **Document pet inheritance** - Clarify stat scaling rules
3. **Runtime talent changes** - Allow dynamic talent modification
