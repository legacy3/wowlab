---
title: How Sims Work
description: The simulation process from start to finish
nextSteps:
  - 02-concepts/01-damage-calculation
  - 02-concepts/02-stats-and-resources
  - 02-concepts/03-auras-and-procs
---

# How Sims Work

A simulation recreates combat by processing events in time order. The engine handles GCDs, cooldowns, procs, and damage calculations while your rotation provides the decision-making.

## Event-driven simulation

Everything is an event with a timestamp:

| Event           | When               | What happens                         |
| --------------- | ------------------ | ------------------------------------ |
| `GcdEnd`        | GCD expires        | Rotation evaluates, next spell casts |
| `CastComplete`  | Cast finishes      | Spell effects apply                  |
| `SpellDamage`   | After travel time  | Damage hits target                   |
| `AuraTick`      | Periodic interval  | DoT/HoT tick fires                   |
| `AuraExpire`    | Duration ends      | Buff/debuff removed                  |
| `AutoAttack`    | Swing timer        | Melee hit, check procs               |
| `ResourceTick`  | Every 100ms        | Regeneration applies                 |
| `CooldownReady` | CD expires         | Spell usable                         |
| `ChargeReady`   | Recharge completes | Charge restored                      |

The event queue sorts by time. The engine processes one event, which may schedule more events, then moves to the next.

## The simulation loop

<Mermaid chart={`
sequenceDiagram
    participant Q as EventQueue
    participant S as Simulation
    participant H as SpecHandler
    participant R as Rotation

    loop Until fight ends
        Q->>S: Pop next event
        S->>S: Advance time
        alt GcdEnd
            S->>H: on_gcd()
            H->>R: evaluate()
            R->>H: Cast spell X
            H->>S: Apply spell
            S->>Q: Schedule CastComplete
        else CastComplete
            S->>H: on_cast_complete()
            H->>Q: Schedule SpellDamage
        else SpellDamage
            S->>H: on_spell_damage()
            H->>S: Record damage
        end
    end

`} />

## GCD and casting

When `GcdEnd` fires:

1. Rotation evaluates (JIT-compiled native code)
2. Result says which spell to cast (or wait)
3. Engine checks resources and cooldowns
4. If valid, spell begins casting
5. New `GcdEnd` scheduled for GCD duration later

Instant casts schedule `CastComplete` immediately. Cast-time spells schedule it after cast time.

## Cooldowns and charges

Spells track cooldown state:

- **Simple cooldowns**: One use, then wait
- **Charged cooldowns**: Multiple charges, recharge over time

When a spell casts, the engine:

1. Deducts a charge (or starts cooldown)
2. Schedules `ChargeReady` or `CooldownReady` event

Your rotation sees this via `cd.spell.ready`, `cd.spell.charges`, etc.

## Damage application

Spell damage flows through the damage pipeline:

1. Base damage calculated (coefficient \* attack power)
2. Multipliers applied (buffs, debuffs, versatility)
3. Crit roll (if success, multiply by crit modifier)
4. Damage recorded to results

See [Damage Calculation](/dev/docs/02-concepts/01-damage-calculation) for details.

## Proc handling

Procs trigger on specific events:

- **On cast**: When spell casting begins
- **On hit**: When damage applies
- **On crit**: When damage crits
- **On tick**: When DoT/HoT ticks

Two proc systems:

- **RPPM**: Procs per minute scaled by haste, with bad luck protection
- **Fixed chance**: Simple percentage chance per trigger

See [Auras & Procs](/dev/docs/02-concepts/03-auras-and-procs) for details.

## Batch processing

Simulations run many iterations to get statistical results:

1. Initialize with base configuration
2. Run iteration 1 with seed 0
3. Run iteration 2 with seed 1
4. ... repeat N times
5. Aggregate results (mean, std dev, percentiles)

Each iteration has different RNG (crit rolls, proc triggers) producing a distribution of outcomes.

## Why not in the browser?

The engine compiles rotations to native machine code using Cranelift JIT. Browsers sandbox JavaScript and cannot execute arbitrary machine code.

Running locally also:

- Uses your full CPU (parallelism)
- Keeps simulation data private
- Avoids server costs
