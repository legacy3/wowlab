---
title: Sentinel Service
description: Stateless coordination service handling node management and job orchestration
---

# Sentinel Service

The Sentinel service is the coordination layer between compute nodes, Centrifugo, and the data stores. It is completely stateless, enabling horizontal scaling.

## Core Responsibilities

```mermaid
flowchart TB
    subgraph Sentinel["Sentinel Service"]
        NodeMgmt[Node Management]
        ChunkSched[Chunk Scheduling]
        ProxyHandlers[Proxy Handlers]
        JobAgg[Job Aggregation]
        HealthMon[Health Monitoring]
    end

    subgraph External["External APIs"]
        Register[POST /nodes/register]
        Token[POST /nodes/token]
        Config["GET /config/{hash}"]
        Status[GET /status]
    end

    subgraph Internal["Internal APIs (Proxy)"]
        Connect[POST /proxy/connect]
        Subscribe[POST /proxy/subscribe]
        Publish[POST /proxy/publish]
        Refresh[POST /proxy/refresh]
        RPC[POST /proxy/rpc]
    end

    External --> Sentinel
    Internal --> Sentinel
```

## External HTTP Endpoints

### Node Registration

```
POST /nodes/register
Auth: Ed25519 Signature
```

Registers a new compute node with the system.

**Request Headers:**

```
X-Signature: <ed25519-signature>
X-Timestamp: <unix-ms>
X-Nonce: <uuid>
```

**Request Body:**

```json
{
  "pubkey": "base64-encoded-ed25519-public-key"
}
```

**Response:**

```json
{
  "id": "node-uuid",
  "claimCode": "XXXX-XXXX"
}
```

### Token Acquisition

```
POST /nodes/token
Auth: Ed25519 Signature
```

Issues a short-lived Centrifugo JWT for WebSocket connection.

```mermaid
sequenceDiagram
    participant Node
    participant Sentinel
    participant Supabase
    participant Centrifugo

    Node->>Sentinel: POST /nodes/token + signature
    Sentinel->>Sentinel: Verify Ed25519 signature
    Sentinel->>Supabase: Check node exists
    Supabase-->>Sentinel: Node data
    Sentinel->>Sentinel: Create JWT (15min expiry)
    Sentinel-->>Node: {jwt, expires_at}
    Node->>Centrifugo: WSS connect with JWT
```

**Response:**

```json
{
  "jwt": "eyJhbGciOiJIUzI1NiIs...",
  "expiresAt": 1234567890
}
```

### Config Retrieval

```
GET /config/{hash}
Auth: Ed25519 Signature
```

Fetches a simulation configuration by its content hash.

## Proxy Endpoints

These endpoints are called by Centrifugo, not directly by clients.

### Connect Proxy

```
POST /proxy/connect
Auth: X-Centrifugo-Proxy-Secret header
```

Validates new WebSocket connections and sets connection metadata.

```mermaid
sequenceDiagram
    participant Client
    participant Centrifugo
    participant Sentinel
    participant Redis

    Client->>Centrifugo: WSS connect (JWT)
    Centrifugo->>Centrifugo: Verify JWT
    Centrifugo->>Sentinel: POST /proxy/connect
    Sentinel->>Sentinel: Verify proxy secret
    Sentinel->>Redis: EVALSHA heartbeat
    Redis-->>Sentinel: {backlog, OK}
    Sentinel-->>Centrifugo: {result: {user, expire_at, meta}}
    Centrifugo-->>Client: Connected
```

### Subscribe Proxy

```
POST /proxy/subscribe
Auth: X-Centrifugo-Proxy-Secret header
```

Authorizes channel subscriptions based on user identity.

### Publish Proxy

```
POST /proxy/publish
Auth: X-Centrifugo-Proxy-Secret header
```

Handles chunk completion messages from nodes.

### Refresh Proxy

```
POST /proxy/refresh
Auth: X-Centrifugo-Proxy-Secret header
```

Issues refreshed JWTs and updates heartbeat timestamps.

### RPC Proxy

```
POST /proxy/rpc
Auth: X-Centrifugo-Proxy-Secret header
```

Handles RPC requests like `getConfig` and `getAssignedChunks`.

## Proxy Secret Validation

Every proxy endpoint MUST verify the secret:

```rust
fn verify_proxy_secret(req: &Request) -> Result<()> {
    let secret = req.headers()
        .get("X-Centrifugo-Proxy-Secret")
        .ok_or(AuthError::MissingSecret)?;

    if secret != env::var("CENTRIFUGO_PROXY_SECRET")? {
        return Err(AuthError::InvalidSecret);
    }
    Ok(())
}
```

This prevents:

- Direct HTTP access to proxy endpoints
- Spoofing the `user` field

## Background Tasks

Background tasks run on a single leader instance to avoid duplicate work:

```mermaid
flowchart TD
    subgraph Leader["Leader Election"]
        Check{Acquire Lock?}
        Check -->|Yes| Leader[Run as Leader]
        Check -->|No| Follower[Skip]
    end

    subgraph Tasks["Background Tasks"]
        Health[Health Monitor]
        LockRecovery[Stuck Lock Recovery]
        ChunkReclaim[Chunk Reclamation]
    end

    Leader --> Tasks
```

```rust
// Leader election for background tasks (30s lease)
let leader_key = "background:leader";
let acquired = redis.set_nx_ex(leader_key, instance_id, 30).await?;
if acquired {
    // This instance is the leader - run background tasks
    run_health_monitor().await;
    run_lock_recovery().await;
    // Refresh lease periodically while running
}
```

## Health Check

```
GET /status
Auth: None
```

Returns system health information:

```json
{
  "status": "healthy",
  "redis": "connected",
  "centrifugo": "connected",
  "supabase": "connected",
  "metrics": {
    "active_nodes": 42,
    "active_jobs": 5,
    "chunks_per_minute": 1200
  }
}
```

## Scaling

Sentinels scale horizontally with no coordination:

```mermaid
flowchart LR
    subgraph Incoming["Incoming Traffic"]
        R1[Request 1]
        R2[Request 2]
        RN[Request N]
    end

    LB[Load Balancer]

    subgraph Instances["Sentinel Instances"]
        S1[Sentinel 1]
        S2[Sentinel 2]
        S3[Sentinel 3]
        S4[Sentinel 4]
    end

    R1 --> LB
    R2 --> LB
    RN --> LB

    LB --> S1
    LB --> S2
    LB --> S3
    LB --> S4
```

Add or remove instances at any time. No warm-up required.
